namespace ca.mcgill.ecse223.quoridor.controller;

use QuoridorGame.ump;

class PawnBehavior {
	depend ca.mcgill.ecse223.quoridor.model.Direction;
	depend ca.mcgill.ecse223.quoridor.model.Tile;
	depend ca.mcgill.ecse223.quoridor.model.PlayerPosition;
	depend ca.mcgill.ecse223.quoridor.model.GamePosition;
	depend java.util.*;

    0..1 -> 0..1 Game currentGame;
    0..1 -> 0..1 Player player;

    pawnSM {
    	Playing {
			finishGame -> Finished;
			Setup {
				startGame[ getCurrentPawnColumn() == 9 ] -> AtEastEdge; 
				startGame[ getCurrentPawnColumn() == 8 ] -> NextToEastEdge;
				startGame[ getCurrentPawnColumn() < 8 ] -> InMiddle;		
			}
			InMiddle{
				moveRight [ isLegalStep(MoveDirection.East) && getCurrentPawnColumn() == 6 ] -> /{movePawnRight();} NextToEastEdge;
				moveRight [ isLegalStep(MoveDirection.East) && getCurrentPawnColumn() < 7 ]-> /{movePawnRight();} InMiddle;
			}
			NextToEastEdge{
				moveRight [ isLegalStep(MoveDirection.East) && getCurrentPawnColumn() == 7 ] -> /{movePawnRight();} AtEastEdge;
			}
			AtEastEdge { 
				moveRight / { illegalMove(); } -> AtEastEdge;
			}
		} 
		Finished {
		
		}
	}

    // Returns the current row number of the pawn
    int getCurrentPawnRow() { 
    	Player player  = currentGame.getCurrentPosition().getPlayerToMove();
		if (player.hasGameAsWhite()) {
			return currentGame.getCurrentPosition().getWhitePosition().getTile().getRow();
		} else {
			return currentGame.getCurrentPosition().getBlackPosition().getTile().getRow();
		}
	}
    // Returns the current column number of the pawn
    int getCurrentPawnColumn() {  
    	Player player  = currentGame.getCurrentPosition().getPlayerToMove();
		if (player.hasGameAsWhite()) {
			return currentGame.getCurrentPosition().getWhitePosition().getTile().getColumn();
		} else {
			return currentGame.getCurrentPosition().getBlackPosition().getTile().getColumn();
		}
	}
    // Returns if it is legal to step in the given direction
    boolean isLegalStep(MoveDirection dir) {
    	GamePosition gp = currentGame.getCurrentPosition();
    	int row = 0;
    	int col = 0;
    	int newRow = 0;
    	int newCol = 0;
    	if (player.hasGameAsWhite()) {
    		row =  gp.getWhitePosition().getTile().getRow();
    		col = gp.getWhitePosition().getTile().getColumn();
    	} else {
    		row =  gp.getBlackPosition().getTile().getRow();
    		col = gp.getBlackPosition().getTile().getColumn();
    	}
    	
    	// Check direction
    	if (dir == MoveDirection.East ){
    		newCol = col +1;
    		newRow = row;
    	} else {
    		return false; //TODO: Remaining Directions
    	}
    	BoardGraph bg = new BoardGraph();
		bg.syncEdges();
    	return bg.isAdjacent(row,col,newRow,newCol); 
    }
    // Returns if it is legal to jump in the given direction
    boolean isLegalJump(MoveDirection dir) { return false; }

    // Action to be called when an illegal move is attempted
    void illegalMove() {
    	//throw new InvalidMoveException("");
 	 }
 	 
 	 void movePawnRight(){
 	 	GamePosition gp = currentGame.getCurrentPosition();
 	 	if (player.hasGameAsWhite()) {
			PlayerPosition old = gp.getWhitePosition();
			Tile t = old.getTile();
			int newRow = t.getRow();
			int newCol = t.getColumn() +1;
			Tile newTile = getTile(newRow, newCol);
			PlayerPosition newPos = new PlayerPosition(player, newTile);
			gp.setWhitePosition(newPos);
		} else {		
			PlayerPosition old = gp.getBlackPosition();
			Tile t = old.getTile();
			int newRow = t.getRow();
			int newCol = t.getColumn() +1;
			Tile newTile = getTile(newRow, newCol);
			PlayerPosition newPos = new PlayerPosition(player, newTile);
			gp.setBlackPosition(newPos);	
		}
 	 }
 	 
 	 Tile getTile(int row, int col) {
		Iterator<Tile> itr = currentGame.getQuoridor().getBoard().getTiles().iterator();
		while (itr.hasNext()) {
			Tile t = itr.next();
			if (t.getRow() == row && t.getColumn() == col) {
				return t;
			}
		}
		return null;
	}
    
    // Enumeration for the possible moving directions
    // (directions are from the viewpoint of white player)
    enum MoveDirection { East, South, West, North; }
}
