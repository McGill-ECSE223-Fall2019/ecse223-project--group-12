namespace ca.mcgill.ecse223.quoridor.controller;
use QuoridorGame.ump;
class PawnBehavior {
	depend ca.mcgill.ecse223.quoridor.model.Tile;
	depend ca.mcgill.ecse223.quoridor.model.PlayerPosition;
	depend ca.mcgill.ecse223.quoridor.model.GamePosition;
	depend java.util.*;
    0..1 -> 0..1 Game currentGame;
    0..1 -> 0..1 Player player;
    pawnSM {
    	Playing {
			Setup {
				startGame[ getCurrentPawnRow() == 1 ] -> AtNorthEdge;
				startGame[ getCurrentPawnColumn() == 9 ] -> AtEastEdge;
				startGame[ getCurrentPawnRow() == 9 ] -> AtSouthEdge;
				startGame[ getCurrentPawnColumn() == 9 ] -> AtWestEdge;
				startGame[ getCurrentPawnColumn() <= 8 &&  getCurrentPawnColumn() >= 1 && getCurrentPawnRow() <= 8 &&  getCurrentPawnRow() >= 1] -> InMiddle;	
			}
			InMiddle{
				moveUp [ isLegalStep(MoveDirection.North) && getCurrentPawnRow() == 2 ] -> /{movePawn(MoveDirection.North);} AtNorthEdge;
				moveUp [ isLegalStep(MoveDirection.North) && getCurrentPawnRow() > 2 ]-> /{movePawn(MoveDirection.North);} InMiddle;
				moveUp [!isLegalStep(MoveDirection.North) && isLegalJump(MoveDirection.North) && getCurrentPawnRow() == 3] -> /{jumpPawn(MoveDirection.North);} AtNorthEdge;
				moveUp [!isLegalStep(MoveDirection.North) && isLegalJump(MoveDirection.North) && getCurrentPawnRow() > 3] -> /{jumpPawn(MoveDirection.North);} InMiddle;		
				
				moveRight [ isLegalStep(MoveDirection.East) && getCurrentPawnColumn() == 8 ] -> /{movePawn(MoveDirection.East);} AtEastEdge;
				moveRight [ isLegalStep(MoveDirection.East) && getCurrentPawnColumn() < 8 ]-> /{movePawn(MoveDirection.East);} InMiddle;
				
				moveDown [ isLegalStep(MoveDirection.South) && getCurrentPawnRow() == 8 ] -> /{movePawn(MoveDirection.South);} AtSouthEdge;
				moveDown [ isLegalStep(MoveDirection.South) && getCurrentPawnRow() < 8 ]-> /{movePawn(MoveDirection.South);} InMiddle;
				moveDown [!isLegalStep(MoveDirection.South) && isLegalJump(MoveDirection.South) && getCurrentPawnRow() == 7] -> /{jumpPawn(MoveDirection.South);} AtSouthEdge;
				moveDown [!isLegalStep(MoveDirection.South) && isLegalJump(MoveDirection.South) && getCurrentPawnRow() < 7] -> /{jumpPawn(MoveDirection.South);} InMiddle;
				
				moveLeft [ isLegalStep(MoveDirection.West) && getCurrentPawnColumn() == 2 ] -> /{movePawn(MoveDirection.West);} AtWestEdge;
				moveLeft [ isLegalStep(MoveDirection.West) && getCurrentPawnColumn() > 2 ]-> /{movePawn(MoveDirection.West);} InMiddle;
							
			}
			AtNorthEdge{
				moveUp / { illegalMove(); } -> AtNorthEdge;
				
				moveRight [ isLegalStep(MoveDirection.East) && getCurrentPawnColumn() == 8 ] -> /{movePawn(MoveDirection.East);} AtEastEdge;
				moveRight [ isLegalStep(MoveDirection.East) && getCurrentPawnColumn() < 8 ]-> /{movePawn(MoveDirection.East);} AtNorthEdge;
				
				moveDown [ isLegalStep(MoveDirection.South) ]-> /{movePawn(MoveDirection.South);} InMiddle;
				moveDown [!isLegalStep(MoveDirection.South) && isLegalJump(MoveDirection.South)] -> /{jumpPawn(MoveDirection.South);} InMiddle;
				
				moveLeft [ isLegalStep(MoveDirection.West) && getCurrentPawnColumn() == 2 ] -> /{movePawn(MoveDirection.West);} AtWestEdge;
				moveLeft [ isLegalStep(MoveDirection.West) && getCurrentPawnColumn() > 2 ]-> /{movePawn(MoveDirection.West);} AtNorthEdge;
					
			}
			AtEastEdge {
				moveRight / { illegalMove(); } -> AtEastEdge;
				
				moveLeft [ isLegalStep(MoveDirection.West) ]-> /{movePawn(MoveDirection.West);} InMiddle;	
				
				moveUp [ isLegalStep(MoveDirection.North) && getCurrentPawnRow() == 2 ] -> /{movePawn(MoveDirection.North);} AtNorthEdge;
				moveUp [ isLegalStep(MoveDirection.North) && getCurrentPawnRow() > 2 ]-> /{movePawn(MoveDirection.North);} AtEastEdge;
				moveUp [!isLegalStep(MoveDirection.North) && isLegalJump(MoveDirection.North)] -> /{jumpPawn(MoveDirection.North);} AtEastEdge;
				
				moveDown [ isLegalStep(MoveDirection.South) && getCurrentPawnRow() == 8 ] -> /{movePawn(MoveDirection.South);} AtSouthEdge;
				moveDown [ isLegalStep(MoveDirection.South) && getCurrentPawnRow() < 8 ]-> /{movePawn(MoveDirection.South);} AtEastEdge;
				moveDown [!isLegalStep(MoveDirection.South) && isLegalJump(MoveDirection.South)] -> /{jumpPawn(MoveDirection.South);} AtEastEdge;		
				
			}
			AtSouthEdge{
				moveDown / { illegalMove(); } -> AtSouthEdge;
				
				moveUp [ isLegalStep(MoveDirection.North) ]-> /{movePawn(MoveDirection.North);} InMiddle;
				moveUp [!isLegalStep(MoveDirection.North) && isLegalJump(MoveDirection.North)] -> /{jumpPawn(MoveDirection.North);} InMiddle;
				
				moveRight [ isLegalStep(MoveDirection.East) && getCurrentPawnColumn() == 8 ] -> /{movePawn(MoveDirection.East);} AtEastEdge;
				moveRight [ isLegalStep(MoveDirection.East) && getCurrentPawnColumn() < 8 ]-> /{movePawn(MoveDirection.East);} AtSouthEdge;
				
				moveLeft [ isLegalStep(MoveDirection.West) && getCurrentPawnColumn() == 2 ] -> /{movePawn(MoveDirection.West);} AtWestEdge;
				moveLeft [ isLegalStep(MoveDirection.West) && getCurrentPawnColumn() > 2 ]-> /{movePawn(MoveDirection.West);} AtSouthEdge;
					
			}
			AtWestEdge{
				moveLeft / { illegalMove(); } -> AtWestEdge;
				
				moveRight [ isLegalStep(MoveDirection.East) ]-> /{movePawn(MoveDirection.East);} InMiddle;

				moveUp [ isLegalStep(MoveDirection.North) && getCurrentPawnRow() == 2 ] -> /{movePawn(MoveDirection.North);} AtNorthEdge;
				moveUp [ isLegalStep(MoveDirection.North) && getCurrentPawnRow() > 2 ]-> /{movePawn(MoveDirection.North);} AtWestEdge;
				moveUp [!isLegalStep(MoveDirection.North) && isLegalJump(MoveDirection.North)] -> /{jumpPawn(MoveDirection.North);} AtWestEdge;
					
				moveDown [ isLegalStep(MoveDirection.South) && getCurrentPawnRow() == 8 ] -> /{movePawn(MoveDirection.South);} AtSouthEdge;
				moveDown [ isLegalStep(MoveDirection.South) && getCurrentPawnRow() < 8 ]-> /{movePawn(MoveDirection.South);} AtWestEdge;
				moveDown [!isLegalStep(MoveDirection.South) && isLegalJump(MoveDirection.South)] -> /{jumpPawn(MoveDirection.South);} AtWestEdge;	
				
			}
		}
	}
    // Returns the current row number of the pawn
    int getCurrentPawnRow() {
		if (player.hasGameAsWhite()) {
			return currentGame.getCurrentPosition().getWhitePosition().getTile().getRow();
		} else {
			return currentGame.getCurrentPosition().getBlackPosition().getTile().getRow();
		}
	}
    // Returns the current column number of the pawn
    int getCurrentPawnColumn() {
		if (player.hasGameAsWhite()) {
			return currentGame.getCurrentPosition().getWhitePosition().getTile().getColumn();
		} else {
			return currentGame.getCurrentPosition().getBlackPosition().getTile().getColumn();
		}
	}
    // Returns if it is legal to step in the given direction
    boolean isLegalStep(MoveDirection dir) {
    	int row = getCurrentPawnRow();
    	int col = getCurrentPawnColumn();
    	int newRow = row; // initial values to be updated
    	int newCol = col;
    	// Check direction
    	if (dir == MoveDirection.East ){
    		newRow = row;
    		newCol = col +1;
    	} else if (dir == MoveDirection.West){
			newRow = row;
			newCol = col -1;
		} else if (dir == MoveDirection.South){
			newRow = row + 1;
			newCol = col;
		} else if (dir == MoveDirection.North){
			newRow = row - 1;
			newCol = col;
		}
    	BoardGraph bg = new BoardGraph();
		bg.syncWallEdges();
		bg.syncStepMoves();
		if(bg.isAdjacent(row,col,newRow,newCol)){
			return true;
		}else{
			return false;
		}
    }
    // Returns if it is legal to jump in the given direction
    boolean isLegalJump(MoveDirection dir) {
    System.out.println("hhassad");
        int row = getCurrentPawnRow();
    	int col = getCurrentPawnColumn();
    	int newRow = row; // initial values to be updated
    	int newCol = col;
    	// Check direction
    	if (dir == MoveDirection.East ){
    		newRow = row;
    		newCol = col + 2;
    	} else if (dir == MoveDirection.West){
			newRow = row;
			newCol = col - 2;
		} else if (dir == MoveDirection.South){
			newRow = row + 2;
			newCol = col;
		} else if (dir == MoveDirection.North){
			newRow = row - 2;
			newCol = col;
		}
    	BoardGraph bg = new BoardGraph();
		bg.syncJumpMoves();
		if(bg.isAdjacent(row,col,newRow,newCol)){
		System.out.println("yayy");
			return true;
		}else{
			return false;
		}
    }
    // Action to be called when an illegal move is attempted
    void illegalMove() throws InvalidMoveException{
    	throw new InvalidMoveException("Illegal move!");
 	 }
 	 void jumpPawn(MoveDirection dir){
 	  	GamePosition gp = currentGame.getCurrentPosition();
 	 	System.out.println("hhh");
 	 	if (player.hasGameAsWhite()) {
			PlayerPosition currentPosition = gp.getWhitePosition();
			Tile currentTile = currentPosition.getTile();
			Tile newTile = getTargetTile(currentTile, dir);
			newTile = getTargetTile(newTile, dir);
			PlayerPosition newPos = new PlayerPosition(player, newTile);
			gp.setWhitePosition(newPos);
		} else {		
			PlayerPosition currentPosition = gp.getBlackPosition();
			Tile currentTile = currentPosition.getTile();
			Tile newTile = getTargetTile(currentTile, dir);
			newTile = getTargetTile(newTile, dir);
			PlayerPosition newPos = new PlayerPosition(player, newTile);
			gp.setBlackPosition(newPos);	
		}
		QuoridorController.confirmMove();
 	 }
 	 
 	 void movePawn(MoveDirection dir){
 	 	GamePosition gp = currentGame.getCurrentPosition();
 	 	
 	 	if (player.hasGameAsWhite()) {
			PlayerPosition currentPosition = gp.getWhitePosition();
			Tile currentTile = currentPosition.getTile();
			Tile newTile = getTargetTile(currentTile, dir);
			PlayerPosition newPos = new PlayerPosition(player, newTile);
			gp.setWhitePosition(newPos);
		} else {		
			PlayerPosition currentPosition = gp.getBlackPosition();
			Tile currentTile = currentPosition.getTile();
			Tile newTile = getTargetTile(currentTile, dir);
			PlayerPosition newPos = new PlayerPosition(player, newTile);
			gp.setBlackPosition(newPos);	
		}
		QuoridorController.confirmMove();
 	 }
 	Tile getTile(int row, int col) {
		Iterator<Tile> itr = currentGame.getQuoridor().getBoard().getTiles().iterator();
		while (itr.hasNext()) {
			Tile t = itr.next();
			if (t.getRow() == row && t.getColumn() == col) {
				return t;
			}
		}
		return null;
	}
	Tile getTargetTile(Tile currentTile, MoveDirection dir){
		if (dir == MoveDirection.East){
			int newRow = currentTile.getRow();
			int newCol = currentTile.getColumn() +1;
			return getTile(newRow, newCol);
		} else if (dir == MoveDirection.West){
			int newRow = currentTile.getRow();
			int newCol = currentTile.getColumn() -1;
			return getTile(newRow, newCol);
		} else if (dir == MoveDirection.South){
			int newRow = currentTile.getRow() + 1;
			int newCol = currentTile.getColumn();
			return getTile(newRow, newCol);
		} else if (dir == MoveDirection.North){
			int newRow = currentTile.getRow() - 1;
			int newCol = currentTile.getColumn();
			return getTile(newRow, newCol);
		}
		return null;
	}
    // Enumeration for the possible moving directions
    // (directions are from the viewpoint of white player)
    enum MoveDirection { East, South, West, North; }
}