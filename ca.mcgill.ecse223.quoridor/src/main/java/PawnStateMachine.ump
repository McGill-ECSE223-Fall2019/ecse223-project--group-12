namespace ca.mcgill.ecse223.quoridor.controller;
use QuoridorGame.ump;
class PawnBehavior {
	depend ca.mcgill.ecse223.quoridor.model.Tile;
	depend ca.mcgill.ecse223.quoridor.model.PlayerPosition;
	depend ca.mcgill.ecse223.quoridor.model.GamePosition;
	depend java.util.*;
    0..1 -> 0..1 Game currentGame;
    0..1 -> 0..1 Player player;
    pawnSM {
    	Playing {
			Setup {
				startGame[ getCurrentPawnColumn() == 9 ] -> AtEastEdge;
				startGame[ getCurrentPawnColumn() <= 8 ] -> InMiddle;		
			}
			InMiddle{
				moveUp [ isLegalStep(MoveDirection.North) && getCurrentPawnRow() == 2 ] -> /{movePawn(MoveDirection.North);} AtNorthEdge;
				moveUp [ isLegalStep(MoveDirection.North) && getCurrentPawnRow() > 2 ]-> /{movePawn(MoveDirection.North);} InMiddle;
				
				moveRight [ isLegalStep(MoveDirection.East) && getCurrentPawnColumn() == 8 ] -> /{movePawn(MoveDirection.East);} AtEastEdge;
				moveRight [ isLegalStep(MoveDirection.East) && getCurrentPawnColumn() < 8 ]-> /{movePawn(MoveDirection.East);} InMiddle;
				
				moveDown [ isLegalStep(MoveDirection.South) && getCurrentPawnRow() == 8 ] -> /{movePawn(MoveDirection.South);} AtSouthEdge;
				moveDown [ isLegalStep(MoveDirection.South) && getCurrentPawnRow() < 8 ]-> /{movePawn(MoveDirection.South);} InMiddle;
				
				moveLeft [ isLegalStep(MoveDirection.West) && getCurrentPawnColumn() == 2 ] -> /{movePawn(MoveDirection.West);} AtWestEdge;
				moveLeft [ isLegalStep(MoveDirection.West) && getCurrentPawnColumn() > 2 ]-> /{movePawn(MoveDirection.West);} InMiddle;
							
			}
			AtNorthEdge{
				moveUp / { illegalMove(); } -> AtNorthEdge;
			}
			AtEastEdge {
				moveRight / { illegalMove(); } -> AtEastEdge;
			}
			AtSouthEdge{
				moveDown / { illegalMove(); } -> AtSouthEdge;
			}
			AtWestEdge{
				moveLeft / { illegalMove(); } -> AtWestEdge;
			}
		}
	}
    // Returns the current row number of the pawn
    int getCurrentPawnRow() {
    	Player player  = currentGame.getCurrentPosition().getPlayerToMove();
		if (player.hasGameAsWhite()) {
			return currentGame.getCurrentPosition().getWhitePosition().getTile().getRow();
		} else {
			return currentGame.getCurrentPosition().getBlackPosition().getTile().getRow();
		}
	}
    // Returns the current column number of the pawn
    int getCurrentPawnColumn() {
    	Player player  = currentGame.getCurrentPosition().getPlayerToMove();
		if (player.hasGameAsWhite()) {
			return currentGame.getCurrentPosition().getWhitePosition().getTile().getColumn();
		} else {
			return currentGame.getCurrentPosition().getBlackPosition().getTile().getColumn();
		}
	}
    // Returns if it is legal to step in the given direction
    boolean isLegalStep(MoveDirection dir) {
    	int row = getCurrentPawnRow();
    	int col = getCurrentPawnColumn();
    	int newRow = row; // initial values to be updated
    	int newCol = col;
    	// Check direction
    	if (dir == MoveDirection.East ){
    		newRow = row;
    		newCol = col +1;
    	} else if (dir == MoveDirection.West){
			newRow = row;
			newCol = col -1;
		} else if (dir == MoveDirection.South){
			newRow = row + 1;
			newCol = col;
		} else if (dir == MoveDirection.North){
			newRow = row - 1;
			newCol = col;
		}
    	BoardGraph bg = new BoardGraph();
		bg.syncWallEdges();
    	return bg.isAdjacent(row,col,newRow,newCol);
    }
    // Returns if it is legal to jump in the given direction
    boolean isLegalJump(MoveDirection dir) { return false; }
    // Action to be called when an illegal move is attempted
    void illegalMove() {
    	//throw new InvalidMoveException("");
 	 }
 	 void movePawn(MoveDirection dir){
 	 	GamePosition gp = currentGame.getCurrentPosition();
 	 	
 	 	if (player.hasGameAsWhite()) {
			PlayerPosition currentPosition = gp.getWhitePosition();
			Tile currentTile = currentPosition.getTile();
			Tile newTile = getTargetTile(currentTile, dir);
			PlayerPosition newPos = new PlayerPosition(player, newTile);
			gp.setWhitePosition(newPos);
		} else {		
			PlayerPosition currentPosition = gp.getBlackPosition();
			Tile currentTile = currentPosition.getTile();
			Tile newTile = getTargetTile(currentTile, dir);
			PlayerPosition newPos = new PlayerPosition(player, newTile);
			gp.setBlackPosition(newPos);	
		}
 	 }
 	Tile getTile(int row, int col) {
		Iterator<Tile> itr = currentGame.getQuoridor().getBoard().getTiles().iterator();
		while (itr.hasNext()) {
			Tile t = itr.next();
			if (t.getRow() == row && t.getColumn() == col) {
				return t;
			}
		}
		return null;
	}
	Tile getTargetTile(Tile currentTile, MoveDirection dir){
		if (dir == MoveDirection.East){
			int newRow = currentTile.getRow();
			int newCol = currentTile.getColumn() +1;
			return getTile(newRow, newCol);
		} else if (dir == MoveDirection.West){
			int newRow = currentTile.getRow();
			int newCol = currentTile.getColumn() -1;
			return getTile(newRow, newCol);
		} else if (dir == MoveDirection.South){
			int newRow = currentTile.getRow() + 1;
			int newCol = currentTile.getColumn();
			return getTile(newRow, newCol);
		} else if (dir == MoveDirection.North){
			int newRow = currentTile.getRow() - 1;
			int newCol = currentTile.getColumn();
			return getTile(newRow, newCol);
		}
		return null;
	}
    // Enumeration for the possible moving directions
    // (directions are from the viewpoint of white player)
    enum MoveDirection { East, South, West, North; }
}